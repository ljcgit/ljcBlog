### 如何判断一个对象是否应该回收：
+ 引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。
> 该算法的缺点很难解决对象之间相互循环引用的问题。
+ 可达性分析算法：通过一系列的称为“GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

### 垃圾收集算法:
+ 标记-清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收所有标记的对象。
> 主要不足：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行会过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

+ 复制算法：将可用内存按容量分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
> 该算法将内存缩小到原来的一半所需代价太高。

+ 标记-整理算法：标记过程仍然与”标记-清除“算法一样，但后续步骤不是直接对可回收对象进行整理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

+ 分代收集算法：当前商业虚拟机主流。是把Java堆分为新生代和老年代。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须要使用”标记-清理“或者”标记-整理“算法来进行回收。

## 垃圾收集器
![HotSpot虚拟机的垃圾收集器](https://upload-images.jianshu.io/upload_images/16503287-ffc843745e3bfc1d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

+ Serial收集器：该收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。
+ ParNew收集器：就是Serial收集器的多线程版本。
+ Parallel Scavenge收集器：CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。同时Parallel Scavenge收集器还具有自适应的调节策略。
+ Serial Odd收集器：是一个单线程收集器，使用“标记-整理算法”。主要意义是在于给Client模式下的虚拟机使用。
+ Parallel Old收集器：Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。在注重吞吐良以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。
+ CMS收集器：是一种以获取最短回收停顿时间为目标的收集器。整个过程分为4个步骤：
> 1.初始标记
2.并发标记
3.重新标记
4.并发清除
其中，初始标记和重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。
+ G1收集器：G1是一款面向服务端应用的垃圾收集器。
> 具有以下特点：
1.并行与并发
2.分代收集
3.空间整合
4.可预测的停顿

 在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域。虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。

> G1收集器运作大致可划分为以下几个步骤：
1.初始标记
2.并发标记
3.最终标记
4.筛选回收
初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS(Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建对象，这阶段耗时较长，但可与用户程序并发执行。但最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可**并行执行**。最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。
