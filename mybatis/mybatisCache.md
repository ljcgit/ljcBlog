## 1 MyBatis缓存机制
+ 一级缓存（本地缓存）：sqlSession级别的缓存。一级缓存是一直开启的。与数据库同一次会话期间查询到的数据会放到本地缓存中。以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库。
> 一级缓存失效情况：
1.sqlSession不同
2.sqlSession相同，查询条件不同
3.sqlSession相同，两次查询之间执行了增删改操作
4.sqlSession相同，手动清除了一级缓存

 

+ 二级缓存（全局缓存）
> 数据会从二级缓存中获取，查出的数据都会被默认先放在一级缓存中。只有会话提交或者关闭以后，一级缓存中的数据才会被转移到二级缓存中。


> 在调用接口的方法获取对象的时候，会先查看缓存中使得否存在相应的对象，如果存在就会返回该对象的引用。（比较两个通过相应条件返回的对象会为true)。


## 2.开启二级缓存
+  <setting name="cacheEnabled" value="true"/>
+ 在mapper.xml中进行设置：    <cache blocking="" eviction="" flushInterval="" readOnly="" size="" type=""></cache>
> **1.evication：缓存的回收策略**
                LRU  ——最近最少使用的，移除最长时间不被使用的对象（默认）
                FIFO ——先进先出
                SOFT ——软引用，移除基于垃圾回收器状态和软引用规则的对象
                 WEAK  ——弱引用，更积极地移除基于垃圾收集器状态和弱引用规则的对象
**2.flushInterval:缓存刷新间隔，缓存多长时间清空一次，默认不清空（毫秒）**
**3.readOnly:是否只读**
           tue：只读，mybatis认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。mybatis为了加快获取速度，直接就会将数据在缓存中的引用交给用户。不安全，速度快。
          false：非只读，mybatis觉得数据可能会被修改。mybatis会利用序列化和反序列化技术克隆一份新的数据给你。安全，速度慢。
**4.size：缓存存放多少元素**
**5.type：指定自定义缓存的全类名，实现Cache接口即可**

+ POJP实现序列化

## 3.和缓存有关的设置
+ cacheEnabled=true:false    （二级缓存关闭）
+ 每个select标签都有useCache="true":"false"   （二级缓存不使用）
+ 每个增删改标签的：flushCache=true    一级和二级缓存都会被清除
+ sqlSession.clearCache()   只是清除当前session的一级缓存
+ localCacheScope：本地缓存作用域（一级缓存SESSION）；当前会话的所有数据保存在会话缓存中。

缓存击穿效果：当数据库的数据的数据大量被缓存在缓存中时，如果缓存失效了，就会导致有大量数据在某一时刻都去访问数据库，就会导致数据库的压力突然增大。
