Paxos是一种分布式一致性算法，常在CAP中的C出现。

Paxos有一个虚拟场景，即拜占庭将军问题。
> **拜占庭将军问题**:一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。

> 系统的问题在于，将军中可能出现叛徒，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。假设有9位将军投票，其中1名叛徒。8名忠诚的将军中出现了4人投进攻，4人投撤离的情况。这时候叛徒可能故意给4名投进攻的将领送信表示投票进攻，而给4名投撤离的将领送信表示投撤离。这样一来在4名投进攻的将领看来，投票结果是5人投进攻，从而发起进攻；而在4名投撤离的将军看来则是5人投撤离。这样各支军队的一致协同就遭到了破坏。
由于将军之间需要通过信使通讯，叛变将军可能通过伪造信件来以其他将军的身份发送假投票。而即使在保证所有将军忠诚的情况下，也不能排除信使被敌人截杀，甚至被敌人间谍替换等情况。因此很难通过保证人员可靠性及通讯可靠性来解决问题。
假使那些忠诚（或是没有出错）的将军仍然能通过多数决定来决定他们的战略，便称达到了拜占庭容错。在此，票都会有一个默认值，若消息（票）没有被收到，则使用此默认值来投票。


## 算法的实现
首先将议员的角色分为 proposers，acceptors，和 learners（允许身兼数职）。proposers 提出提案，提案信息包括提案编号和提议的 value；acceptor 收到提案后可以接受（accept）提案，若提案获得多数派（majority）的 acceptors 的接受，则称该提案被批准（chosen）；learners 只能“学习”被批准的提案。划分角色后，就可以更精确的定义问题：
+ 决议（value）只有在被 proposers 提出后才能被批准（未经批准的决议称为“提案+（proposal）”）；
+ 在一次 Paxos 算法的执行实例中，只批准（chosen）一个 value；
+ learners 只能获得被批准（chosen）的 value。

#### 决议的提出与批准

通过一个决议分为两个阶段：

1.  prepare阶段：
    1.  proposer选择一个提案编号n并将prepare请求发送给acceptors中的一个多数派；
    2.  acceptor收到prepare消息后，如果提案的编号大于它已经回复的所有prepare消息(回复消息表示接受accept)，则acceptor将自己上次接受的提案回复给proposer，并承诺不再回复小于n的提案；
2.  批准阶段：
    1.  当一个proposer收到了多数acceptors对prepare的回复后，就进入批准阶段。它要向回复prepare请求的acceptors发送accept请求，包括编号n和根据P2c决定的value（如果根据P2c没有已经接受的value，那么它可以自由决定value）。
    2.  在不违背自己向其他proposer的承诺的前提下，acceptor收到accept请求后即批准这个请求。

## Multi-Paxos中消息流的图形表示
![](https://upload-images.jianshu.io/upload_images/16503287-3e45c8065cd5cb9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
> 首先Client发起请求，Proposer先将提案发送给Acceptor，Acceptor收到后向Proposer发送回复，Proposer收到大多数的回复后，就进入批准环节。Proposer向Acceptor发送accept请求，包括编号信息，Acceptor收到请求后即批准该请求。

